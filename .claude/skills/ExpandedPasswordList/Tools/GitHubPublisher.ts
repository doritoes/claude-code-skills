#!/usr/bin/env bun
/**
 * GitHubPublisher.ts - Publish Results to GitHub
 *
 * Pushes cracked passwords to a public GitHub repository.
 *
 * @author PAI (Personal AI Infrastructure)
 * @license MIT
 */

import { existsSync, mkdirSync, writeFileSync, copyFileSync, rmSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { $ } from "bun";
import { StateManager } from "./StateManager";

// =============================================================================
// Configuration
// =============================================================================

const SKILL_DIR = dirname(dirname(fileURLToPath(import.meta.url)));
const DATA_DIR = resolve(SKILL_DIR, "data");
const RESULTS_DIR = resolve(DATA_DIR, "results");
const PUBLISH_DIR = resolve(DATA_DIR, "publish-tmp");

// Default repo (can be overridden by env or args)
const DEFAULT_REPO = "doritoes/expanded-passwords";

// =============================================================================
// Publisher Implementation
// =============================================================================

/**
 * Generate README content
 */
function generateReadme(stats: {
  totalHibp: number;
  rockyouFiltered: number;
  candidates: number;
  cracked: number;
  hard: number;
  crackRate: number;
}): string {
  return `# Expanded Password List

Cleartext passwords derived from [HIBP Pwned Passwords](https://haveibeenpwned.com/Passwords) that **supplement** rockyou.txt.

## Statistics

| Metric | Value |
|--------|-------|
| HIBP Source Hashes | ${stats.totalHibp.toLocaleString()} |
| Rockyou Overlaps (filtered) | ${stats.rockyouFiltered.toLocaleString()} |
| Candidates (new) | ${stats.candidates.toLocaleString()} |
| **Cracked** | **${stats.cracked.toLocaleString()}** |
| Hard (uncracked) | ${stats.hard.toLocaleString()} |
| Crack Rate | ${stats.crackRate.toFixed(2)}% |

## Methodology

1. Download HIBP Pwned Passwords (SHA-1 hashes)
2. Filter out hashes that match rockyou.txt
3. Crack remaining hashes using rockyou.txt + OneRuleToRuleThemAll.rule
4. Extract cleartext passwords

## Files

| File | Description |
|------|-------------|
| \`passwords/combined.txt\` | All cracked passwords (sorted, unique) |
| \`passwords/combined.txt.gz\` | Compressed version |
| \`hard-passwords/uncracked-sha1.txt\` | SHA-1 hashes that survived cracking |
| \`statistics/stats.json\` | Machine-readable metrics |

## Usage

\`\`\`bash
# Download combined list
curl -LO https://github.com/${DEFAULT_REPO}/raw/main/passwords/combined.txt.gz
gunzip combined.txt.gz

# Use with hashcat
hashcat -m 0 hashes.txt combined.txt
\`\`\`

## Why This Exists

rockyou.txt is the de facto standard wordlist, but it only contains ~14M passwords.
HIBP contains ~1B passwords from real breaches. This project extracts the passwords
from HIBP that are NOT in rockyou, giving you millions of additional real-world
passwords for security testing.

## License

Public domain. No attribution required.

---

Generated by [PAI ExpandedPasswordList Skill](https://github.com/doritoes/PAI)
`;
}

/**
 * Generate stats.json
 */
function generateStats(state: ReturnType<StateManager["load"]>): object {
  return {
    generated: new Date().toISOString(),
    source: "HIBP Pwned Passwords",
    pipeline: {
      hibpHashes: state.download.totalHashes,
      rockyouFiltered: state.filter.rockyouMatches,
      candidates: state.filter.candidates,
      cracked: state.results.crackedPasswords,
      uncracked: state.results.hardPasswords,
    },
    crackRate:
      state.filter.candidates > 0
        ? (state.results.crackedPasswords / state.filter.candidates) * 100
        : 0,
    methodology: "rockyou.txt + OneRuleToRuleThemAll.rule",
  };
}

/**
 * Publish results to GitHub
 */
async function publish(options: {
  repo?: string;
  create?: boolean;
  dryRun?: boolean;
} = {}): Promise<void> {
  const { repo = DEFAULT_REPO, create = false, dryRun = false } = options;

  const state = new StateManager(DATA_DIR);
  const pipelineState = state.load();

  // Validate results exist
  const passwordsFile = resolve(RESULTS_DIR, "passwords.txt");
  if (!existsSync(passwordsFile)) {
    console.error("No results to publish. Run Collect workflow first.");
    process.exit(1);
  }

  console.log("GitHubPublisher");
  console.log("===============");
  console.log(`Repository: ${repo}`);
  console.log(`Dry run: ${dryRun}`);
  console.log("");

  // Prepare publish directory
  if (existsSync(PUBLISH_DIR)) {
    rmSync(PUBLISH_DIR, { recursive: true });
  }
  mkdirSync(PUBLISH_DIR, { recursive: true });

  // Clone or init repo
  console.log("Preparing repository...");

  if (!dryRun) {
    try {
      // Try to clone existing repo
      await $`gh repo clone ${repo} ${PUBLISH_DIR}`.quiet();
      console.log("  Cloned existing repository");
    } catch {
      if (create) {
        // Create new repo
        console.log("  Creating new repository...");
        await $`gh repo create ${repo} --public --clone --description "Expanded password list from HIBP"`.cwd(dirname(PUBLISH_DIR));
        mkdirSync(PUBLISH_DIR, { recursive: true });
      } else {
        console.error(`Repository ${repo} not found. Use --create to create it.`);
        process.exit(1);
      }
    }
  }

  // Create directory structure
  const passwordsDir = resolve(PUBLISH_DIR, "passwords");
  const statsDir = resolve(PUBLISH_DIR, "statistics");
  const hardDir = resolve(PUBLISH_DIR, "hard-passwords");

  mkdirSync(passwordsDir, { recursive: true });
  mkdirSync(statsDir, { recursive: true });
  mkdirSync(hardDir, { recursive: true });

  // Copy passwords
  console.log("Copying files...");

  const srcPasswords = resolve(RESULTS_DIR, "passwords.txt");
  const dstPasswords = resolve(passwordsDir, "combined.txt");
  copyFileSync(srcPasswords, dstPasswords);
  console.log(`  passwords/combined.txt`);

  // Compress
  if (!dryRun) {
    await $`gzip -k -f ${dstPasswords}`.quiet();
    console.log(`  passwords/combined.txt.gz`);
  }

  // Generate stats
  const stats = generateStats(pipelineState);
  writeFileSync(resolve(statsDir, "stats.json"), JSON.stringify(stats, null, 2));
  console.log(`  statistics/stats.json`);

  // Generate README
  const readme = generateReadme({
    totalHibp: pipelineState.download.totalHashes,
    rockyouFiltered: pipelineState.filter.rockyouMatches,
    candidates: pipelineState.filter.candidates,
    cracked: pipelineState.results.crackedPasswords,
    hard: pipelineState.results.hardPasswords,
    crackRate:
      pipelineState.filter.candidates > 0
        ? (pipelineState.results.crackedPasswords / pipelineState.filter.candidates) * 100
        : 0,
  });
  writeFileSync(resolve(PUBLISH_DIR, "README.md"), readme);
  console.log(`  README.md`);

  // Copy uncracked hashes if available
  const uncrackedSrc = resolve(RESULTS_DIR, "uncracked.txt");
  if (existsSync(uncrackedSrc)) {
    copyFileSync(uncrackedSrc, resolve(hardDir, "uncracked-sha1.txt"));
    console.log(`  hard-passwords/uncracked-sha1.txt`);
  }

  console.log("");

  if (dryRun) {
    console.log("DRY RUN - Files prepared but not pushed");
    console.log(`Preview at: ${PUBLISH_DIR}`);
    return;
  }

  // Commit and push
  console.log("Committing and pushing...");

  try {
    await $`git add .`.cwd(PUBLISH_DIR).quiet();
    await $`git commit -m "Update passwords: ${pipelineState.results.crackedPasswords.toLocaleString()} cracked"`.cwd(PUBLISH_DIR).quiet();
    const result = await $`git push`.cwd(PUBLISH_DIR).quiet();

    // Get commit hash
    const commitHash = await $`git rev-parse HEAD`.cwd(PUBLISH_DIR).text();

    state.recordPublish(commitHash.trim());

    console.log("");
    console.log("Publish Complete");
    console.log("================");
    console.log(`Commit: ${commitHash.trim().slice(0, 8)}`);
    console.log(`Repository: https://github.com/${repo}`);
  } catch (e) {
    console.error(`Git error: ${e}`);
    process.exit(1);
  }

  // Cleanup
  rmSync(PUBLISH_DIR, { recursive: true });
}

// =============================================================================
// CLI Usage
// =============================================================================

if (import.meta.main) {
  const args = process.argv.slice(2);

  if (args[0] === "--help" || args[0] === "-h") {
    console.log(`
GitHubPublisher - Publish results to GitHub

Usage:
  bun GitHubPublisher.ts                   Publish to default repo
  bun GitHubPublisher.ts --repo <owner/repo>   Specify repository
  bun GitHubPublisher.ts --create          Create repo if doesn't exist
  bun GitHubPublisher.ts --dry-run         Preview without pushing

Options:
  --repo <owner/repo>   Target repository (default: ${DEFAULT_REPO})
  --create              Create repository if it doesn't exist
  --dry-run             Prepare files but don't push

Requirements:
  - GitHub CLI (gh) authenticated
  - Results collected from Hashcrack
`);
    process.exit(0);
  }

  // Parse arguments
  let repo = DEFAULT_REPO;
  let create = false;
  let dryRun = false;

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "--repo":
        repo = args[++i];
        break;
      case "--create":
        create = true;
        break;
      case "--dry-run":
        dryRun = true;
        break;
    }
  }

  try {
    await publish({ repo, create, dryRun });
  } catch (e) {
    console.error(`Error: ${(e as Error).message}`);
    process.exit(1);
  }
}
